[toc]
# LSP
## Liskov Substitution Principle
- If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T
- Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it
## 里氏替换原则
- 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。
- 所有引用基类的地方必须能透明地使用其子类的对象，但是，反过来就不行了，有子类出现的地方，父类未必就能适应
## 继承
- 在面向对象的语言中，继承是必不可少的、非常优秀的语言机制
### 优点
1. 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性
2. 提高代码的重用性
3. 子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同
4. 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，很多开源框架的扩展接口都是通过继承父类来完成的
5. 提高产品或项目的开放性
6. 采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑
### 缺点
1. 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
2. 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。
### 扩展
1. Java使用extends关键字来实现继承，它采用了单一继承的规则
2. C++则采用了多重继承的规则，一个子类可以继承多个父类。
3. 从整体上来看，利大于弊，怎么才能让“利”的因素发挥最大的作用，同时减少“弊”带来的麻烦呢？解决方案是引入里氏替换原则
## 规范
1. 子类必须完全实现父类的方法
2. 子类可以有自己的个性
3. 覆盖或实现父类的方法时输入参数可以被放大
```text
方法中的输入参数称为前置条件
里氏替换原则要求制定一个契约，就是父类或接口
契约制定了，也就同时制定了前置条件和后置条件，
前置条件就是你要让我执行，就必须满足我的条件；
后置条件就是我执行完了需要反馈(返回值)，标准是什么
```
4. 覆写或实现父类的方法时输出结果可以被缩小
```text
父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，里氏替换原则就要求S必须小于等于T，
分两种情况，
如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重。
如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的，参考上面讲的前置条件
```
## 注意
- 在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则
- 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承
- 向下转型（downcast）是不安全的，从里氏替换原则来看，就是有子类出现的地方父类未必就可以出现
- 重写Override（参数，返回值一致）
- 重载Overload（只有方法名一致，参数返回值可以不一致）
## 最佳实践
```text
在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，
把子类当做父类使用，子类的“个性”被抹杀——委屈了点；
把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。
```