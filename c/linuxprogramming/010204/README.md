# 010204

> 开发系统导引
>
> 应用程序
> > 应用程序通常存放在系统为之保留的特定目录中 \
> > 为正常使用系统所提供的程序，包括用于程序开发的工具，都可在`/usr/bin`中找到 \
> > 系统管理员为某个特定的主机或本地网络添加的程序通常可以在目录`/usr/local/bin`或`/opt`中找到 \
> > 系统管理员一般喜欢使用`/opt`和`/usr/local`目录，因为它们分离了厂商提供及后续添加的文件与系统本身提供的应用程序 \
> > 升级操作时只需要保留`/opt`和`/usr/local`里的内容即可 \
> > 建议对于系统级的应用程序，可以将它放在`/usr/local`目录中来运行和访问所需要的文件 \
> > 对于开发应用和个人的应用程序，最好在自己的`home`目录中使用一个文件夹来存放 \
> > 其他一些功能特性和编程系统可能有其自己的目录结构和程序目录。比如X视窗系统，通常安装在`/usr/X11`或`/usr/bin/X11`目录 \
> > `Linux`发行版通常使用`X`视窗系统的`X.Org`基金会版本，基于修订版7<sub>X11R7</sub> \
> > 其他`UNIX`系统可能选择`X`视窗系统的其他版本，如Solaris的Sun Open Windows被安装在/usr/openwin目录中 \
> > `gcc`一般位于`/usr/bin`或`/usr/local/bin`目录中，但它会从其他位置运行各种编译器支持的应用程序 \
> > 这个位置是在编译编译器本身时指定的，并且随主机类型的不同而不同。`GNU C/C++`编译器的各个工具和`GNU`专业的头文件都保存在这里 \
> > 对于`Linux`系统，位置可能是`/usr/lib/gcc/`目录下的一个版本特定的子目录。本人`ArchLinux`机器上是`/usr/lib/gcc/x86_64-pc-linux-gnu/12.2.1`
>
> 头文件
> > 用C语言及其他语言进行程序设计时，需要头文件提供对常量的定义和对系统函数及库函数的调用的声明 \
> > 对C语言来说，这些头文件几乎总是位于`/usr/include`目录及其子目录中 \
> > 那些依赖于特定Linux版本的头文件通常可在目录`/usr/include/sys`和`/usr/include/linux`中找到 \
> > 其他编程系统也有各自的头文件，这些头文件被存储在可被相应编译器自动搜索到的目录里 \
> > 如X视窗系统的`/usr/include/X11`目录和GUN C++的`/usr/include/c++`目录 \
> > 在调用C语源编译器时，可以使用`-I`标志来包含保存在子目录或非标准位置的头文件 \
> > 如`gcc -I/usr/openwin/include fred.c`，指示编译器不仅在标准位置，也在`/usr/openwin/include`目录中查找程序`fred.c`中包含的头文件 \
> > 想查看从程序中返回退出状态的#define定义的名字。`grep EXIT_ /usr/include/*.h`以.h结尾的文件中搜索字符串`EXIT_`
>
> 库文件
> > 库是一组预先编译好的函数的集合，这些函数都是按照可重用的原则编写的 \
> > 通常由一组相互关联的函数组成以执行某项常见的任务，比如屏幕处理函数库`curses`和`ncurses`库，数据库访问例库`dbm`库 \
> > 标准系统库文件一般存储在`/lib`和`/usr/lib`目录中 \
> > C语言编译器<sub>确切地说是链接器</sub>，需要知道要搜索哪些库文件，在默认情况下，只搜索标准C语言库，因为以前计算机速度还很慢而且CPU运行周期还很昂贵 \
> > 仅把库文件放在标准目录中，就希望编译器能够找到它是不够的，库文件必须遵循特定的命名规范并且需要在命令行中明确指定 \
> > 库文件的名字总是以`lib`开头，随后的部分指明这是什么库，如c代表C语言库，m代表数学库 \
> > 文件名最后部分以`.`开始，然后给出库文件的类型 `.a`代表传统的静态函数库 `.so`代表共享函数库 \
> > 函数库通常同时以静态库和共享库两种格式存在，可以使用`ls /usr/lib`命令查看
> > > 通过给出完整的库文件路径名来告诉编译器要搜索的库文件 `gcc -o fred fred.c /usr/lib/libm.a` \
> > > 通过`-l`标志来告诉编译器要搜索的库文件`gcc -o fred fred.c -lm`
> >
> > `-lm`代表标准库目录`/usr/lib`中名为`libm.a`的函数库，如果有共享库`libm.so`，编译器会自动选择共享库 \
> > 虽然库文件和头文件一样通常都保存在标准位置，但是也可以通过`-L`标志为编译器增加库的搜索路径 \
> > `gcc -o x11fred -L/usr/openwin/lib x11fred.c -lX11`表示用`/usr/openwin/lib`目录中的`libX11`库版本来编译和连接程序`x11fred` \
>
> 静态库
> > 函数库最简单的形式是一组处于**准备好使用**状态的目标文件，当程序需要使用函数中的某个函数时，它包含一个声明该函数的头文件 \
> > 编译器和链接器负责将程序代码和函数库结合在一起以组成一个单独的可执行文件。必须使用`-l`选项指明除标准C语言运行库外还需要使用的库 \
> > 静态库也被称作归档文件`archive`，按惯例它们的文件名都以`.a`结尾，比如标准C语言函数库`/usr/lib/libc.a`和`/usr/lib/libm.a` \
> > 使用`ar`很容易创建和维护自己的静态库 \
> > 应该尽可能把函数分别保存到不同的源文件中，如果函数需要访问公共数据，可以把它们放在同一个源文件中，并使用在该文件中声明的静态变量
>
> 静态库实验
> > 编写源文件 [fred.c](source/fred.c) 和 [bill.c](source/bill.c) \
> > 编译 fred.c 和 bill.c `gcc -c bill.c fred.c` 获得 fred.o 和 bill.o \
> > 为库文件创建头文件[lib.h](head/lib.h)，头文件中声明库文件中的函数 \
> > 编写调用库文件程序 [program.c](source/program.c) \
> > 编译 `gcc -c program.c` \
> > 链接方式1 `gcc program.o bill.o` \
> > `ar crv libfoo.a bill.o fred.o`使用`ar`创建归档文件`libfoo.a`并将目标文件`bill.o`和`fred.o`添加进去 \
> > `ranlib libfoo.a`为函数库生成内容表，`Berkeley UNIX`衍生系统必须执行此操作；Linux中使用的是GNU这一步骤可有可无 \
> > 链接方式2 `gcc program.o libfoo.a` 使用库文件`libfoo.a`链接程序 \
> > 链接方式3 `gcc program.o -L. -lfoo` 使用`-l`选项指明访问`libfoo.a`函数库或`libfoo.so`的共享库，因未保存在标准位置，必须使用`-L`选项来告诉编译器在`.`当前目录查找 \
> > `nm a.out`查看`a.out`包含哪些函数，可以看到只包含实际需要的函数，虽然程序中的头文件包含函数库中所有的函数声明，但是并不会将整个函数库包含在最终的程序中 \
> > `nm libfoo.a`查看`libfoo.a`包含那些函数
>
> 共享库
> > 静态库的一个缺点是，当同时运行许多应用程序并且它们都使用来自同一个函数库的函数时，内存中就会有同一函数的多份副本，而且在程序文件自身中也有多份同样的副本。 \
> > 支持共享库的UNIX系统和Linux系统可以克服静态库的缺点。 \
> > 当一个程序使用共享库时，链接方式是：
> > > 程序本身不再包含函数代码，而是引用运行时可访问的共享代码。 \
> > > 当编译好的程序被装载到内存中执行时，函数引用被解析并产生对共享库的调用，如果有必要，共享库才被加载到内存中 \
> > > 系统只保留共享库的一份副本供许多应用程序同时使用，并且在磁盘上也仅保存一份。\
> > > 共享库的更新可以独立于依赖它的应用程序 \
> > > 如文件`/lib/libm.so`是对实际库文件修订版本<sub>/lib/libm.so.N N代表主版本号</sub>的符号链接 \
> > > 当Linux启动应用程序时，会考虑应用程序需要的函数库版本，以防止函数库的新版本致使旧的应用程序不能使用。
> >
> > 共享库除了比静态库占用空间小之外，方便更新<sub>共享库发生变化后，程序不需要再次编译</sub>，但相比于静态库执行效率略低 \
> > 对于Linux系统，负责装载共享库并解析客户程序函数引用的程序<sub>动态装载器</sub>是`ld.so`，也可能是`ld-linux.so.2`、`ld-lsb.so.2`、`ld-lsd.so.3` \
> > 用于搜索共享库的额外位置可以在文件`/etc/ld.so.conf`中配置，如果修改了这个文件，需要执行`ldconfig`来处理 \
> > `ldd a.out` 查看一个程序需要的共享库 \
> > 共享库在许多方面类似Windows中使用的动态链接库。`.so`库对应于`.DLL`文件，它们都是在程序运行时加载，而`.a`库类似于`.LIB`文件，它们都包含在可执行程序中。
>
> 共享库实验
> > `-fPIC`或`-fpic`参数，编译出位置无关的目标文件`gcc -c -fPIC bill.c fred.c` \
> > 链接生成共享库`libfoo.so`，`gcc -shared bill.o fred.o -o libfoo.so` \
> > 生成目标文件`gcc -c program.c` \
> > 使用绝对路径调用共享库`gcc program.o /home/leo/libfoo.so` \
> > 使用相对路径调用共享库`gcc program.o ../lib/libfoo.so` \
> > **不太好使**：*调用者与共享库在同一目录下，调用共享库不好使`gcc program.o libfoo.so`* \
> > 将库文件所在目录添加到`LD_LIBRARY_PATH`环境变量中`export LD_LIBRARY_PATH=./`调用共享库`gcc program.o -L. -lfoo` \
> > 将库文件移动到默认的动态库路径 `/lib`、`/usr/lib`中，调用共享库`gcc program.o -L. -lfoo` \
> > 修改[bill.c](source/bill.c)源文件，重新生成so库，直接运行`a.out`可以发现调用的是更新后的`bill.c`，即共享库发生变化后，程序不需要再次编译

|项目|UNIX|Windows|
|:---|:---|:---|
|目标模块|func.o|FUNC.OBJ|
|静态函数库|lib.a|LIB.LIB|
|共享库|*.so|*.DLL|
|程序|a.out|a.EXE|

[return](../README.md)
