/**
 * mac_arg.c -- 带参数的宏
 *
 * 记号
 * 可以把宏的替换体看作是记号（token）型字符串，而不是字符型字符串
 * C预处理器记号是宏定义的替换体中单独的词
 * 用空白把这些词分开
 * 	如
 * 		#define FOUR 2*2 //定义一个记号 2*2 序列，
 * 		#define SIX 2 * 3 //定义三个记号，2、*、3
 * 替换体中有多个空格时，字符型字符串和记号型字符串的处理方式不同
 * 	当解释为字符型字符串，把空格视为替换体的一部分
 * 	当解释为记号型字符串，把空格视为替换体中各记号的分隔符
 * 在实际应用中，一些c编译器把宏替换视为字符串而不是记号，
 * c编译器处理记号的方式比预处理器复杂
 * 由于编译器理解C语言的规则，所以不要求代码中用空格来分隔记号，如
 * 	c编译器可以把 2*2 直接视为三个记号，因为它可以识别2是常量，*是运算符
 *
 * 重定义常量
 * 先定义一次，后续又定义一次，这个过程是重定义常量，
 *
 * 不同的实现采用不同的重定义方案，
 * 除非新定义与旧定义相同，否则有些实现会将其视为错误
 * 另外一些实现允许重定义，但会给出警告
 *
 * ANSI标准采用第一种方案，只有新定义和旧定义完全相同才允许重定义
 *    #define SIX 2 * 3//三个记号，额外的空格不算替换体的一部分
 *    #define SIX 2 * 3//三个记号，额外的空格不算替换体的一部分
 *    #define SIX 2*3//只有一个记号，所以与上面两个不同，如果需要重定义宏 使用#undef指令
 *
 * 如果确实需要重定义常量，使用const关键字和作用域规则更容易些
 * 
 * 在#define中使用参数可以创建外形和作用与函数类似的类函数宏
 * 带有参数的宏看上去很像函数，因为这样的宏也使用圆括号
 * 类函数宏定义的圆括号中可以有一个或多个参数，随后这些参数出现在替换体中
 *             宏参数
 * #define MEAN(X,Y)   (((X)+(Y))/2)
 *         宏          替换体
 *
 *
 * 切记切记 预处理器不做计算，不求值，只替换字符序列
 *
 * 不要在宏中使用递增或递减运算符
 * 但是++x可以作为函数参数，因为编译器会对++x求值得5后，再把5传递给函数
 *
 */
#include <stdio.h>
#define SQUARE(X) X*X
#define PR(X) printf("The result is %d.\n",X)
int main(void)
{
	int x=5;
	int z;
	printf("x=%d\n",x);
	z=SQUARE(x);//z=x*x
	printf("Evaluating SQUARE(x):");
	PR(z);
	z=SQUARE(2);//2*2
	printf("Evaluating SQUARE(2):");
	PR(z);
	printf("Evaluating SQUARE(x+2):");
	PR(SQUARE(x+2));                       //x+2*x+2 = 5+2*5+2=17
	printf("Evaluating 100/SQUARE(2):");
	PR(100/SQUARE(2));                      //100/2*2=100
	printf("x is %d.\n",x);
	printf("Evaluating SQUARE(++X):");
	/**
	 * 标准并未对 ++x * ++x 这类运算规定顺序
	 * 所以有些编译器得7*6
	 * 而有些编译器可能在乘法运算之前已经递增了x,所以 7*7=49
	 *
	 * 在c标准中，对该表达式求值的这种情况称为 未定义行为
	 * 无论那种情况，x的开始值都是5,虽然从代码上看只递增了一次，但x的最终值是7
	 *
	 * 解决这类问题的最简单的方法，是避免++x作为宏参数
	 */
	PR(SQUARE(++x));                         //++x*++x=6*7=42
	printf("After incrementing.x is %x.\n",x);
	return 0;
}
