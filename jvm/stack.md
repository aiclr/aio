# Stack

## 帧数据区

- dynamic linking
- return address
- 附加信息

## dynamic linking(指向运行时常量池Constant pool的方法引用)

- 描述

```text
每一个stack frame 内部都包含一个指向运行时常量池中该stack frame所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现dynamic linking。
包含这个引用的目的就是为了支持当前方法的代码能够实现dynamic linking。比如invokedynamic指令。
在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(symbolic reference)保存在class文件的常量池里
比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用用来表示的，
那么dynamic linking的作用就是为了将这些符号引用转换为调用方法的直接引用
```

### 方法的调用--多态

- JVM 将符号引用（#3、#2。。。）转换为调用方法的直接引用与方法的绑定机制有关
- 静态链接（static linking）
    ```text
    当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时
    这种情况下将调用方法的符号引用转换为直接引用的过程称为静态链接 static linking
    ```
- 动态链接（dynamic linking）
    ```text
    如果被调用方法在编译期无法被确定下来，也就是说只能够在程序运行期将调用方法的符号引用转换为直接引用
    由于这种引用转换过程具备动态性因此也被称为dynamic linking
    ```
- 方法的绑定机制：是一个字段、方法、类在符号引用被替换为直接引用的过程，仅发生一次
    - 早期绑定early binding
      ```text
      早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，
      由于明确了被调用的目标方法究竟时哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用
      ```
    - 晚期绑定late binding
      ```text
      如果被调用的方法在编译期无法被确定下来只能在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就是late binding
      ```
- 虚函数--运行期确定----final

```text
Java中任何一个普通方法其实都具备虚函数的特征，相当于c++语言中的虚函数（c++中需要使用关键字virtual来显示定义）
如果java程序中不希望某个方法拥有虚函数的特征，使用关键字final修饰（不能被重写，编译期确定，不再具备多态性）
```

- 多态----类继承，且重写方法

```text
子类对象的多态性前提：1.类的继承 2.方法的重写
面向对象的高级语言，尽管在语法风格上存在差异，但是都支持封装、继承、多态等面向对象特性
具备多态性，就具备early binding和late binding两种绑定方式，使在编译期确定具体调用哪个方法
```

- 虚方法
    - 具有多态的方法
    - 除了静态方法、私有方法、final方法、实例构造器、父类方法
    - invokevirtual：调用所有虚方法（final修饰的方法除外，final修饰的方法也使用invokevirtual指令）
    - invokeinterface：调用接口方法
    -
- 非虚方法
    - 不具有多态的方法
    - invokestatic和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法
    - 方法在编译期确定具体的调用版本，这个版本在运行时不可变
    - 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法
    - invokestatic：调用静态方法，ClassLoaderSubSystem.Linking.Resolve时(解析阶段)确定唯一方法版本
    - invokespecial：调用<init>方法、私有方法、父类方法，解析阶段确定唯一方法版本
- 动态调用指令
    - invokedynamic：动态解析出需要调用的方法，然后执行
    - invokevirtual、invokeinterface、invokestatic、invokespecial指令固化在JVM内部，方法的调用执行不可人为干预
    - invokedynamic指令支持由用户确定方法版本

### 方法重写的本质

1. 找到operand stack 栈顶元素所执行的对象的实际类型，记作c（当调用一个对象的方法时，会先把该方法的对象压入operand stack，通常为invokevirtual）
2. 如果在类型c中找到与常量池中
   描述符、简单名称都相符的方法（查找c中有没有该方法），则进行访问权限校验，如果权限校验通过，则返回这个方法的直接引用，查找过程结束，如果访问权限校验不通过，则返回java.lang.IllegalAccessError异常
3. 如果在类型c中没找到与常量中 描述符、简单名称都相符的方法（查找c中有没有该方法），按照继承关系从下往上依次对c的各个父类进行第二步的搜索和验证
4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常

- IllegalAccessError异常（jar冲突可能会出现）：程序试图访问或修改一个属性或调用一个方法，当这个属性或方法没有权限访问，一般会引起编译器异常，这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。

### 虚方法表

- 在面向对象编程OOP，频繁的使用到动态分派，若每次动态分派的过程都要重新在类的方法元数据中搜索合适的目标，会影响执行效率
- JVM采用在类的方法区建立一个虚方法表virtual method table ，非虚方法不会出现在表中，使用索引表来代替查找
- 每个类中都有一个虚方法表，表中存放着各个方法的实际入口
- 虚方法表在ClassLoaderSubSystem.Linking.resolve(将常量池内的符号引用转换为直接引用)阶段被创建并开始初始化，类的变量初始值准备完成后，JVM会把该类的方法表也初始化完毕

## return address

- 存放调用该方法的Program Counter Register的值，即下一条指令的值
- 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置
    - 一个方法的结束，有两种方式
        - 正常退出时：
            - 调用者的PCRegister的值作为返回地址，即调用该方法的指令的下一条指令的地址
            - 方法的退出是当前stack frame出栈的过程，此时需要恢复上层方法的局部变量表
        - 异常退出时：
            - 返回地址要通过异常表来确定，stack frame不会保存这部分信息
            - 异常退出不会给上层调用者产生任何的返回值

### 返回指令

- 根据实际数据类型确定方法返回值
- ireturn（boolean、byte、char、short、int）
- lreturn（long）
- freturn（float）
- dreturn（double）
- areturn（引用类型）
- return（void 方法、实例初始化方法、类、接口的初始化方法）

### 异常完成出口

- 在方法执行的过程中遇到异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出
- 方法执行过程中抛出异常的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码



























